=head1 Was ist Perl

=head2 Wichtige Konzepte in Perl

=head3 Scalare, Listen, Hashes - Einzahl oder Mehrzahl

=head3 Kontext

=head3 Stringbehandlung

=head3 Reguläre Ausdrücke

    m//xmsi;
    s///gxmsi;

=head3 C<$_> - It und Freunde

C<$1>-C<$9>, C<@ARGV>, C<@_>

=head3 Blöcke

=head3 Kontrollstrukturen

=head3 Subroutinen

=head3 Variablen

=head3 Scoping

=head3 Objektorientierung

=head4 Einfach: blessed References

=head4 Modern: Moose, Moo, Mo, Mouse

=head3 Funktionale Programmierung

=head4 map, grep, sort, Listenkontexte

=head4 Subroutinen wie Daten behandeln/anonyme Subroutinen

=head1 Was ist Mojolicious

=head2 ojo

Diese ist ein Modul für Onliner, welche die Möglichkeiten von Mojolicious (CSS3-Selectoren,
Web-Requests) auf einfach Weise für die Kommandozeile bereit stellen.

    $ perl -Mojo -E 'say g("mojolicio.us")->dom->at("title")->text'

=over 1

=item L<Weitere Informationen|https://metacpan.org/module/ojo>

=item L<Perl-Commandline-Flags|http://perldoc.perl.org/perlrun.html>

=back

=head3 Perl-Kommandozeilenreferenz - praktische Kurzfassung

=head4 -e

Der Parameter, der nach C<-e> kommt ist Perl-Code und wird ausgeführt.

=head4 -E

Wie C<-e>, nur mit Features freigeschalten (Features, die ab Perl Version 
5.10 verfügbar sind und unter Umständen mit der Rückwärtskompatibilität 
brechen).

=head4 -n, -p

Wird in Zusammenhang mit C<-e> und C<-E> verwendet.

Nimmt ähnlich wie C<sed> oder C<awk> Dateiinhalte Zeilenweise entgegen und legt
jede Zeile in Perls "it" (C<$_>) ab. Dateiinhalte werden hierbei als letztes 
Argument in Form des zugehörigen Dateinamens oder über die Standardeingabe 
angenommen.

Folgende Schleife kann man sich dabei vorstellen:

     LINE:
     while (<>) {
         say; # hier kann man etwas mit $_ anstellen
     }

Ähnlich wie in C<awk> ist es auch hier möglich, C<BEGIN { }>- und C<END { }>-
Blöcke im C<-e>/C<-E>-Parameter zu verwenden, in denen Vor- oder 
Nachbereitungsaufgaben der zeilenweisen Abarbeitung durchgeführt werden können.

C<-p> gibt zusätzlich am Ende der Datei den letztgesetzten Inhalt von C<$_> aus.

=head4 -l

Damit kann man die Automatische Zeilenendebehandlung einschalten. D.h. den eingelesenen
Zeilen bei C<-n> und C<-p> wird automatisch der Zeilenumbruch abgeschnitten.

=head4 -a

Splittet eine Zeile bei C<-n> oder C<-p> automatisch an Leerzeichenähnlichen Zeichen 
auf und packt die Teile in das vorbereitete C<@F>.

Leerzeichenähnlich heißt hier im Regelfall Leerzeichen und Tabulator.

C<-F>:

Mit C<-F> kann man bei Verwendung von C<-a> ein Zeichen angeben, an welchem
eine Zeile aufgespalten wird. Das entsprechende Zeichen muss C<-F> als Parameter
mitgegeben werden.

=head4 -M

Das dem C<-M> als Parameter mitgegebene Modul laden (L<perlfunc/"use Module">).
Für mehrere zu ladende Module kann C<-M> mehrmals angegeben werden.

=head4 -I

Gibt als Parameter einen zusätzlichen Pfad an, in dem Perl nach Modulen sucht.
Für mehrere Pfade kann C<-I> mehrmals verwendet werden.

=head4 -c

Prüft lediglich die Syntax eines Perl-Scriptes.

=head4 -w

Schaltet Warnungen ein, die den Programmierer mit zusätzlichen Meldungen
vor Fehlern bewahren sollen.

=head4 -T

Schaltet den Taint-Modus ein. Hier werden alle Daten, die von außerhalb des
Programmes kommen als gefleckt markiert und dürfen erst weiter verwendet werden
(für SQL-Statements oder Ausgaben), wenn sie zunächst gereinigt werden (i.d.R.
in dem man die Daten gegen eine RegEx prüft und daraus dann die eigentlichen
Nutzdaten zieht).

=head4 -d

Schaltet den Debugger zu. Beispielsweise kann man mit C<-d:DNYTProf> den 
Profiler L<Devel::NYTProf> verwenden, um das Programm zu profilen.

C<-de 0>:

Geht direkt in den Debugmodus ohne vorher Code auszuführen. Das ist das Perl-
Äquivalent einer Interaktiven Shellumgebung (sowas wie C<irb> in Ruby oder
ansatzweise der REPL in LISP).

=head2 Warum Mojolicious?

=head3 Warum nicht CGI?

Plack, FastCGI, Parameterbehandlung, Sessionhandling, JSON, REST, Plugins,
Templates, Routen, Modernes Perl, MVC

=head3 Warum nicht Catalyst?

=head3 Warum nicht Dancer?

=head2 Konzepte hinter Mojolicous

=head3 MVC - Model+View+Controler

=head3 Templates

=head4 Embedded-Perl-Template

=head4 Weitere Templates über Plugins verfügbar

=over 1

=item L<https://metacpan.org/module/MojoX::Renderer::HTP>

=item L<https://metacpan.org/module/Mojolicious::Plugin::TtRenderer>

=item L<https://metacpan.org/module/Mojolicious::Plugin::Mason2Renderer>

=back

=head3 Routen

=head3 Controller

=head3 Code-Generierung über das Kommandozeilenprogramm C<mojo>

=head3 Testing

=head3 Deployment

=head4 Reverse Proxy

=head4 CGI, FastCGI, mod_perl

=head1 DBIx::Class - ORM in Perl

=head2 Erste Schritte: "Hello World"

Mojolicious verfügt über einen Mechanismus, der sich C<Mojolicious::Lite> nennt. C<Mojolicious::Lite>
stellt einen vereinfachten prozeduralen Zugang zu Mojolicious dar, über den wie im Stil von "Sinatra" 
(oder wie dat heißt) für Ruby direkt der Controller an die Routendefinition angefügt wird.

Weiterhin ist es in C<Mojolicious::Lite>-Anwendungen möglich, Templates inline im C<__DATA__>-Bereich
am Ende eines Perl-Scriptes abzulegen komplett mit Informationen über den Pfad der Templates innerhalb
der Applikation. Außerdem können Statische Dateien (Javascript-Quellcode, CSS-Stylesheets) ebenfalls
im C<__DATA__>-Teil abgelegt werden zusammen mit ihren Pfadinformationen. Als Krönung ist es auch
möglich, binäre Dateien Base64-Kodiert (über das Kommandozeilenprogramm C<base64>) mit Pfadangabe
unterhalb von C<__DATA__> abzulegen (Bilder).

C<Mojolicious::Lite> eignet sich sehr gut für schnelles Prototyping und für kleine Anwendungen, die
als eine einzelne kompakte Datei verteilt werden sollen.

    $ mojo generate lite_app HelloWorld

Das erzeugte Script ist hier im Projektverzeichnis als Referenz unter C<src/HelloWorld> zu finden.

Das Hello-World-Programm kann mit dem Testserver C<morbo> gestartet werden:

    $ morbo HelloWorld

Jetzt läuft unter Port 3000 auf Localhost die Anwendung und auf der 
Kommandozeile blubbern lustige Debuggingausgaben vor sich hin.

Für den produktiven Einsatz kann das Script als CGI-Script, in einer FastCGI- oder
mod_perl-Umgebung verwendet werden (von letzterem wird i.d.R. abgeraten). Weiterhin
kann der für produktive Umgebungen mitgelieferte Applicationserver hypnotoad, ein
anderer Perl-Applicationserver wie Starman oder gar eine Plack-Umgebung (PSGI) verwendet
werden.

Hinweis: Da C<Mojolicious::Lite> hervorrangend für Prototyping verwendet werden kann, beginnt damit
gelegentlich ein größeres Projekt. Um erstellte Dateien und Templates jetzt nicht mühsam hin und her
kopieren zu müssen, bietet Mojolicious die Möglichkeit, aus einer C<Mojolicious::Lite>-Anwendung heraus
direkt eine komplexere Mojolicious-Anwendung zu erstellen. Dazu muss einfach C<mojo inflate 'Dateiname'>
an der Kommandozeile aufgerufen werden. Dann werden die im C<__DATA__>-Bereich angegeben Dateien
ihrer Pfade entsprechend auf Verzeichnisse aufgeteilt und die Arbeit am großen Mojolicious-Projekt
kann beginnen.

=head3 Walkthrough durch die Begrüßte Welt

=head4 Hashbang!

Sollte klar sein, die Unixtypische SheBang oder Hashbang oder wie auch immer man das nennen möchte.

    #!/usr/bin/env perl

=head4 Mojolicious einbinden

    use Mojolicious::Lite;

Frage: Wo ist C<use strict;> und C<use warnings;>, was Perl-Anfänger in jedem Forum
und von jedem Perl-Profi nahegelegt wird?

Antwort: Der Aufruf C<use Mojolicious::Lite;> schaltet automatisch die Pragmas C<strict>
und C<warnings> ein, welche sonst separat mit L<perlfunc/"use"> aufgerufen werden müssten.

=head4 Ein Plugin verwenden

Plugins werden mit der Subroutine C<plugin> zugeschalten.

    # Documentation browser under "/perldoc"
    plugin 'PODRenderer';

Im C<HelloWorld> ist das Plugin C<PODRenderer> aktiviert, damit kann die Dokumentation
der lokalen Perl-Umgebung bequem im Browser über die URL L<http://localhost:3000/perldoc>
bzw. L<http://localhost:3000/perldoc/perltoc> oder L<http://localhost:3000/perldoc/Modulname>
angezeigt werden.

=head4 Eine Route mit Controller definieren

    get '/' => sub {
      my $self = shift;
      $self->render('index');
    };

Die HTTP-Methode C<'get'>.

Die Route C<'/'>.

Fatcomma (C<=E<gt>>). 
    
Routenparameter C<'/:param1'> mit Wildcards.

Parameterparsing über reguläre Ausdrücke.

Eine anonyme Subroutine (C<sub {}>).

Funktionsargumente entpacken, die Unterschiede und der Nutzen der verschiedenen Herangehensweisen:

    my $self = shift;
    my ( $self, $param1, $param2 ) = @_

Ein Template mit Informationen ausgeben C<render>.

Warum kommt da ein C<;> und bei einer Subroutinendefinition (C<sub subname {}>) nicht? 
Das Semikolon ist hier wichtig.

Weitere Funktionen:

=over 1

=item C<my $value1 = param('param1');>

=item C<my $sessionhashref = session();>

=item C<stash(name =E<gt> $value);>

=item C<flas(name =E<gt> $value);>

=back

=head4 Die Anwendung starten

    app->start;

=head4 Der Data-Bereich mit Inline-Templates und statischen Dateien

    __DATA__

=head4 Dateipfade für Inline-Dateien und -Templates

    @@ index.html.ep

=head4 Perl-Code in Mojolicious-Embedded-Perl-Templates

    % layout 'default';
    % title 'Welcome';
    Welcome to the Mojolicious real-time web framework!

    @@ layouts/default.html.ep
    <!DOCTYPE html>
    <html>
      <head><title><%= title %></title></head>
      <body><%= content %></body>
    </html>

Beispiele und Erklärung für inline-Perl:

    <h1>Perl-Code-Schnippsel für die gesamte Zeile, &quot;;&quot; nicht notwendig</h1>
    <h2>Ohne Ausgabe</h2>
    % say 'Hi'
    <h2>Mit Ausgabe, diese wird vorher HTML-Escaped</h2>
    %= say '3 > 2'
    <h2>Mit Ausgabe, diese wird vorher <u>nicht</u> HTML-Escaped</h2>
    %== say '3 &gt; 2'
    <h1>Perl-Code-Schnippsel, die direkt zwischen HTML verwendet werden können:</h1>
    <h2>Ohne Ausgabe<% say 'Hi' %></h2>
    <h2>Mit Ausgabe, diese wird vorher HTML-Escaped: <%= say '3 > 2' %></h2>
    <h2>Mit Ausgabe, diese wird vorher <u>nicht</u> HTML-Escaped: <%== say '3 &gt; 2' %></h2>

=cut
